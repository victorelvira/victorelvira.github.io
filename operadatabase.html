<!DOCTYPE html>
<html>

<head>
  <title>Opera Database </title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
    }

    .float-parent-element { 
    width: 100%; 
} 
.float-child-element_left { 
    float: left; 
    width: 90%; 
    height: 80px;
}
.float-child-element_right{ 
    float: left; 
    width: 10%; 
    height: 80px;
} 
.left_div { 
    margin-left: 10px; 
} 
.right_div { 
    margin-left: 0px; 
}

    #myInput {
      background-image: url('/css/searchicon.png');
      background-position: 10px 10px;
      background-repeat: no-repeat;
      width: 90%;
      font-size: 16px;
      padding: 12px 20px 12px 40px;
      border: 1px solid #ddd;
      margin-bottom: 12px;
    }

    #myTable {
      border-collapse: collapse;
      width: 100%;
      border: 1px solid #ddd;
      font-size: 18px;
    }

    #myTable th,
    #myTable td {
      text-align: left;
      padding: 12px;
    }

    #myTable tr {
      border-bottom: 1px solid #ddd;
    }

    #myTable tr.header,
    #myTable tr:hover {
      background-color: #f1f1f1;

    }


    th, td {
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {background-color: #f2f2f2;}
  </style>
     
  <script type="text/javascript" src="opera_catalogue.js"></script> 

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script>
// NEXT IS: if field is an array, do something else (append all singers...). SI LO HAGO MUY GENERICO PUEDE SER UN LIO. SI LO HAGO MUY PARTICULAR, SOLO SERVIRIA PARA OPERA.
// NEXT IS: sortable
// NEXT IS: un poco mas flexibilidad en los vectores debajo
// NEXT IS: headers are not headers, but instead a normal filtrable row

var myListColumnHeaders = ["opera", "composer","place","artists","year","label", "type"];
var n_cols = myListColumnHeaders.length;
var properties_vector = ["name.full", "composer.last", "place.opera_house","date.year","label","type"];  // will go in the same order as above

var object_2D = create_2D_object(opera_catalogue, properties_vector, myListColumnHeaders)

ind_artists = myListColumnHeaders.indexOf("artists");
if (ind_artists > -1){ // artists will be displayed
  var column_artists = artists_2_string(opera_catalogue);

  for (var i = 0; i < object_2D.length; i++) {
    console.log(i)
    art_ii = column_artists[i];
    object_2D[i].splice(ind_artists, 0, art_ii); // insert artist
    console.log(object_2D[i][ind_artists])
  }
}


function find_nested_prop_in_JSON(obj, prop, defval){ // allows to go deeper in nested JSONs
    if (typeof defval == 'undefined') defval = null;
    prop = prop.split('.');
    for (var i = 0; i < prop.length; i++) {
        if(typeof obj[prop[i]] == 'undefined')
            return defval;
        obj = obj[prop[i]];

    }
    return obj;
}

function create_2D_object(obj, props, myListColumnHeaders){ // creates 2D object to be filled later in a table
    // var object_2D_internal = Array(obj.length).fill(Array(props.length)); // new Array(obj.length,props.length).fill(null);
    // var object_2D_internal = Array(obj.length);
    //     // Loop to initialize 2D array elements.
    // for (var i = 0; i < obj.length; i++) {
    //     for (var j = 0; j < props.length; j++) {
    //       object_2D_internal[i][j] = null;
    //     }
    // }
    var object_2D_internal =  new Array(obj.length).fill(0).map(() => new Array(props.length).fill(0));

    console.log(obj.length)
    console.log(props.length)
    for (var ii = 0; ii < obj.length; ii++) {
      for (var jj= 0; jj < props.length; jj++) {
        // console.log(obj[i])
        // console.log(props[j])
        element_i_j = find_nested_prop_in_JSON(obj[ii], props[jj],""); // use column string instead of j-position;
        object_2D_internal[ii][jj] = element_i_j;
        // object_2D_internal[ii][jj] = ii + jj;
        // console.log("ii is " + ii)
        // console.log("jj is " + jj)
        // console.log(element_i_j)
        // console.log("size is " + object_2D_internal.length)
      }
    }
    return object_2D_internal;

}


// find_nested_prop_in_JSON(opera_catalogue[0], props,"")


// var data = {"id":1,
// "name":"abc",
// "address":{"streetName":{full:"cde"},"streetId":2}
// };

// var props = 'label';
// console.log('The value of ' + props + ' is ' + find_nested_prop_in_JSON(opera_catalogue[0], props,""));



// table_input is a version of the JSON file in a 2D table tyle (excel), just with the info that is equired above

  // var table_input = opera_catalogue; 

  // const aaa = JSON.parse(table_input[1]);


// var keys = Object.keys(table_input);

  // console.log(typeof(table_input[0]["artists.name"]));
  // console.log(table_input[0]["artists"][1].name);

  // var mylist = opera_catalogue;
//   var myList = [
//   { "name": "abc", "age": 50 },
//   { "age": "25", "hobby": "swimming" },
//   { "name": "xyz", "hobby": "programming" , "age": 75, "bla": 75}
// ];

  // var myListColumnHeaders = ["name", "age", "hobby"];

  
 

  function buildHtmlTable(selector,table_input) { // table_input is a JSON variable. Problem: only will check if fields in the first level are = columns
  // var columns = addAllColumnHeaders(myList, selector);
  var columns = addAllColumnHeadersFixed(myListColumnHeaders, selector);
  // myList = opera_catalogue;
  console.log(table_input.length)
  for (var i = 0; i < table_input.length; i++) {
    var row$ = $('<tr/>');
    for (var colIndex = 0; colIndex < table_input[0].length; colIndex++) { // for each column
      var cellValue = table_input[i][colIndex]; // value of the cell
      if (cellValue == null) {
          cellValue = ""; // empty if not
      }
      // row$.append($('<td/>').html("<a href='file:////Volumes/ext_4TB_3/operas'>" + cellValue + "</a>"));
      row$.append($('<td/>').html("<a>" + cellValue + "</a>"));
    }
    $(selector).append(row$);
  }
  function_on_key_up() // this function is called to account for the initialization of checks and filters
}


function artists_2_string(obj){ // unique function for the opera database. Concatenates the artists in a very specific order

var string_artists =  new Array(obj.length).fill(null);

var bla = obj[0]["artists"][1]["sort"]; // value of the cell
console.log(bla)
// console.log(props.length)
for (var ii = 0; ii < obj.length; ii++) {
  artists_ii = obj[ii]["artists"];
  artists_ii_string = "";
  for (var jj = 0; jj < artists_ii.length; jj++) {
    art_ii_jj = artists_ii[jj]["sort"];
    if (typeof art_ii_jj !== 'undefined'){
      if (artists_ii_string == ""){ // first artist about to be inserted
        artists_ii_string = art_ii_jj;
      }
      else{
        artists_ii_string = artists_ii_string + ", " +  art_ii_jj;
      }
      if (artists_ii[jj]["role"] == "Conductor"){
        artists_ii_string = artists_ii_string + " (conductor)"
      }
        
    }
    // console.log(artists_ii[jj]["sort"]);
    // console.log(jj)
  }
  console.log(artists_ii_string)
  string_artists[ii] = artists_ii_string; 
}
return string_artists
}


// Builds the HTML Table out of JSON myList (object, but only with one level). SO FAR NOT USED!
function buildHtmlTable_from_JSON(selector,table_input) { // table_input is a JSON variable. Problem: only will check if fields in the first level are = columns
  // var columns = addAllColumnHeaders(myList, selector);
  var columns = addAllColumnHeadersFixed(myListColumnHeaders, selector);
  // myList = opera_catalogue;
  console.log(table_input.length)
  for (var i = 0; i < opera_catalogue.length; i++) {
    var row$ = $('<tr/>');
    for (var colIndex = 0; colIndex < columns.length; colIndex++) {
      var cellValue = table_input[i][columns[colIndex]]; // value of the cell
      if (cellValue == null) {
          cellValue = ""; // empty if not
      }
      row$.append($('<td/>').html(cellValue));
    }
    $(selector).append(row$);
  }
}

// Adds a header row to the table and returns the set of columns.
// Need to do union of keys from all records as some records may not contain
// all records.
function addAllColumnHeaders(myList, selector) { // so far not used
  var columnSet = [];
  var headerTr$ = $('<tr/>');

  for (var i = 0; i < myList.length; i++) {
    var rowHash = myList[i];
    for (var key in rowHash) {
      if ($.inArray(key, columnSet) == -1) {
        columnSet.push(key);
        headerTr$.append($('<th/>').html(key));
      }
    }
  }

  $(selector).append(headerTr$);
  // <tr class="header">
  //     <th style="width:20%;">Name</th>
  //     <th style="width:20%;">Country</th>
  //   </tr>
  return columnSet;
}


// Adds a header row to the table and returns the set of columns.
// Simply extracter from a list
function addAllColumnHeadersFixed(myListColumnHeaders, selector) {
  var columnSet = [];
  var headerTr$ = $('<tr/>');

  for (var i = 0; i < myListColumnHeaders.length; i++) {
    key = myListColumnHeaders[i];
    // for (var key in rowHash) {
      // if ($.inArray(key, columnSet) == -1) {
        columnSet.push(key);
        headerTr$.append($('<th/>').html(key));
        console.log($('<th/>').html(key))
      // }
    // }
  }
  console.log(headerTr$)
  $(selector).append(headerTr$);

  return columnSet;
}


</script>


</head>

<body onLoad="buildHtmlTable('#myTable',object_2D)">



  <h2>Opera recordings</h2>

   

  <div class="float-parent-element">
    <div class="float-child-element_left">
      <input class="left_div" type="text" id="myInput"  onkeyup="function_on_key_up()" placeholder="Search..." title="Type" width="20px">
    </div>
    <div class="float-child-element_right">
      <form class="right_div">
        <input type="checkbox" id="videos_check"  onclick="function_on_key_up()"  checked>
        <label for="videos"> videos</label><br>
        <input type="checkbox" id="audios_check" onclick="function_on_key_up()">
        <label for="audios"> audios</label><br>
      </form>
    
    </div>
  </div>

<div>
   <a float="right" id="n_elements">   </a>
  </div>
   
 
    <table id="myTable"  class=”sortable” border="1" style="width:100%;text-align:left;border-collapse:collapse;">
    </table>
   
  
  <script>

//     $(document).ready(function(){ 

// });



    function function_on_key_up() {     // when a key is released

      
      var input, filter, table, tr, td, i, txtValue;
      input = document.getElementById("myInput");
      filter = input.value.toUpperCase();
      table = document.getElementById("myTable");
      tr = table.getElementsByTagName("tr");
      console.log(tr.length)

      filter_vec = filter.split(" "); // all substrings

      // queda eliminar el substring vacio, MEJOR HACERLO AQUI
      const index_space = filter_vec.indexOf(" ");
      if (index_space > -1) { // only splice array when item is found
        filter_vec.splice(index_space);  
      }

      console.log(filter_vec.length)
      count_visible = 0; // appearing elements
      for (i = 1; i < tr.length; i++) { // NEVER MAKE DISAPPEAR THE FIRST ONE
        // flag_i = false; // hidden by default
        var flag_i_vec = new Array(filter_vec.length).fill(false);  // size of number of sub_strings. We will need that all substrings to be true
         
        for (col = 0; col < n_cols; col++) { // for each column
          td = tr[i].getElementsByTagName("td")[col];
          if (td) { // if there is something in td
            // txtValue = td.textContent || td.innerText; //  textContent is more efficient than innerText
            txtValue = td.textContent; //  textContent is more efficient than innerText
            for (k = 0; k < filter_vec.length; k++) { // for all substrings in the filter
            if (txtValue.toUpperCase().indexOf(filter_vec[k]) > -1) { // if filter is a sub-string of txtValue
              // console.log(txtValue.toUpperCase().indexOf(filter) > -1)
                // flag_i = txtValue.toUpperCase().indexOf(filter_vec[k]) > -1 || flag_i
                flag_i_vec[k] = txtValue.toUpperCase().indexOf(filter_vec[k]) > -1 || flag_i_vec[k]
              }
            }
          }
        }
        ind_type = myListColumnHeaders.indexOf("type");
        if (ind_type > -1){ // type exists
          
          td_type = tr[i].getElementsByTagName("td")[ind_type];
          console.log(td_type.textContent )
          if(td_type.textContent  == "video" ){
            element_ii_is_video = true;
          }
          else{
            element_ii_is_video = false;
          }
          if( td_type.textContent == "audio" ){
            element_ii_is_audio = true;
          }
        else{
          element_ii_is_audio = false;
          }

        }


        // if (flag_i) { // if filter is a sub-string of txtValue
          if ( (flag_i_vec.every(v => v === true) &&  ( ( videos_check.checked === true && element_ii_is_video) || ( audios_check.checked === true && element_ii_is_audio)  ))){ // true if all elements of the vector are true
              tr[i].style.display = ""; // displayed
              count_visible = count_visible + 1;
            } else {
              tr[i].style.display = "none";  // hidden
            }
      }
      document.getElementById("n_elements").innerHTML = count_visible + " displayed elements";

    }
  </script>

</body>

</html>